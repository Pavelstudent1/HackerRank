package Warmup;

import java.util.Scanner;

public class P15_Halloween_Party {

	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		
		System.out.print("Enter number of tests: ");
		int T = in.nextInt();
		
		int[] cuts = new int[T];
		System.out.println("Enter a number of cuts: ");
		for (int i = 0; i < cuts.length; i++) {
			cuts[i] = in.nextInt();
			if (cuts[i] < 2) cuts[i] = 2;
		}
		
		numberOfCuts(cuts);
		
		in.close();
	}
	
	/**
	Самое эффективное(и почти единственное) разрезание на кусочки происходит
	так, как будто самый первый кусочек(2 разреза - 1 элемент) "обволакивается"
	такими же кусочками сверху, справа и наискось(квадрат выглядит как срез лука)
	Т.е. каждый чётный "слой" добавляет 2 * X + 1, где Х - кол-во кусочков по любой стороне.
	Нечётные же разрезы, всего лишь удваивают количество элементов одной из сторон квадрата
	(т.к. одним разрезом больше ничего и не сделать, как не порезать одну из сторон).
	В итоге имеем две формулы - для чётного количества разрезов и нечётного.
	Для чётных: (x / 2)^2, где х - требуемо число разрезов
	Для нечётных: (х / 2)^2 + (х / 2)
	Для обоих случаев, дробные части от деления просто отбрасываются.
	Единственный спорный случай по количеству элементов, получаем при 4-х разрезах:
	если 2-ре среза расположить как столбик и поровну порезать 2-мя оставшимися, то получим 3-кусочка;
	если расположить 2 среза в виде квадрата, а оставшиеся 2 расположить в нём крестом,
	то получится плитка из 4-х элементов. По заданию, число элементов должно быть максимальным.
	 **/
	private static void numberOfCuts(int[] c) {
		
		long countOfpieses = 0;
		
		for (int i = 0; i < c.length; i++) {
			
			countOfpieses = 
				(c[i] % 2 == 0 ? 
					(long) Math.pow((c[i] / 2), 2) :
					(long) Math.pow(((c[i] - 1) / 2), 2) + (c[i]/2));
				
			System.out.println(countOfpieses);
			countOfpieses = 0;
		}
	}

}
